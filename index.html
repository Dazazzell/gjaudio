<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MP3 Voting with Appwrite</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
  <script src="https://cdn.jsdelivr.net/npm/appwrite@13.0.0"></script>
  <style>
    #charts-container {
      width: 50%;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <h2>Upload MP3</h2>
  <input type="file" id="fileInput" accept="audio/mpeg" />
  <button id="uploadBtn">Upload</button>
  <br><br>

  <div id="track-list"></div>
  <div id="charts-container"></div>

  <script type="module">
    const client = new Appwrite.Client()
      .setEndpoint("https://cloud.appwrite.io/v1") // or your self-hosted URL
      .setProject("6817cbb2002532589942");

    const account = new Appwrite.Account(client);
    const db = new Appwrite.Databases(client);
    const storage = new Appwrite.Storage(client);

    const databaseId = "6817cc0400031a2bec0f";
    const collectionId = "6817cc890034adeb219f";
    const bucketId = "6817cc1700261a470236";

    let user = null;

    const charts = {};
    const tracks = []; // will be filled dynamically on upload

    await account.createAnonymousSession();
    user = await account.get();

    function ding() {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = ctx.createOscillator();
      const gain = ctx.createGain();
      oscillator.type = 'triangle';
      oscillator.frequency.setValueAtTime(880, ctx.currentTime);
      gain.gain.setValueAtTime(0.001, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.5, ctx.currentTime + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
      oscillator.connect(gain);
      gain.connect(ctx.destination);
      oscillator.start(ctx.currentTime);
      oscillator.stop(ctx.currentTime + 0.4);
    }

    async function fetchVotes(trackId) {
      const res = await db.listDocuments(databaseId, collectionId, [
        Appwrite.Query.equal("trackId", trackId)
      ]);
      let total = 0;
      res.documents.forEach(doc => total += doc.score);
      return {
        average: res.total > 0 ? (total / res.total).toFixed(2) : null,
        count: res.total
      };
    }

    async function updateChart() {
      const levels = {};
      for (const track of tracks) {
        const { average, count } = await fetchVotes(track.id);
        if (!levels[track.level]) {
          levels[track.level] = { labels: [], averages: [], voteCounts: [] };
        }
        levels[track.level].labels.push(track.title);
        levels[track.level].averages.push(average || 0);
        levels[track.level].voteCounts.push(count);
      }

      for (const level in levels) {
        const backgroundColor = `rgba(${Math.random()*200},${Math.random()*200},${Math.random()*200},0.6)`;
        if (!charts[level]) {
          const canvas = document.createElement("canvas");
          const section = document.createElement("div");
          section.innerHTML = `<h3>${level} Level</h3>`;
          section.appendChild(canvas);
          document.getElementById("charts-container").appendChild(section);

          charts[level] = new Chart(canvas.getContext('2d'), {
            type: 'bar',
            data: {
              labels: levels[level].labels,
              datasets: [{
                label: level,
                data: levels[level].averages,
                backgroundColor
              }]
            },
            options: {
              plugins: {
                datalabels: {
                  formatter: (value, context) => {
                    const index = context.dataIndex;
                    return `${value} (${levels[level].voteCounts[index]})`;
                  },
                  anchor: 'end',
                  align: 'top',
                  font: { weight: 'bold' }
                }
              },
              scales: {
                y: { beginAtZero: true, max: 10 }
              }
            },
            plugins: [ChartDataLabels]
          });
        } else {
          charts[level].data.labels = levels[level].labels;
          charts[level].data.datasets[0].data = levels[level].averages;
          charts[level].update();
        }
      }
    }

    async function renderTrack(track) {
      const container = document.getElementById("track-list");
      const div = document.createElement("div");
      div.innerHTML = `
        <h4>${track.title} - ${track.level}</h4>
        <audio controls src="${track.mp3}"></audio>
        <div>
          ${[...Array(10)].map((_, i) =>
            `<button data-score="${i+1}" data-id="${track.id}">${i+1}</button>`).join(' ')}
        </div>
        <p id="result-${track.id}">Loading...</p>
      `;
      container.appendChild(div);

      const updateResults = async () => {
        const res = await fetchVotes(track.id);
        document.getElementById(`result-${track.id}`).textContent =
          res.average ? `Avg: ${res.average} (${res.count} vote${res.count > 1 ? 's' : ''})` : 'No votes yet';
        updateChart();
      };

      updateResults();

      div.querySelectorAll("button").forEach(btn => {
        btn.addEventListener("click", async () => {
          await db.createDocument(databaseId, collectionId, 'unique()', {
            trackId: track.id,
            score: Number(btn.dataset.score),
            userId: user.$id
          });
          ding();
          updateResults();
        });
      });
    }

    document.getElementById("uploadBtn").addEventListener("click", async () => {
      const file = document.getElementById("fileInput").files[0];
      if (!file) return alert("Choose a file first");

      const level = prompt("Enter track level (e.g., JM, JSGM, JIM):");
      const title = prompt("Enter track title:");

      const uploaded = await storage.createFile(bucketId, 'unique()', file);
      const mp3Url = storage.getFileView(bucketId, uploaded.$id);

      const track = {
        id: uploaded.$id,
        title: title || file.name,
        mp3: mp3Url.href,
        level: level || 'Unknown'
      };

      tracks.push(track);
      renderTrack(track);
    });

  </script>
</body>
</html>
