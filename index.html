<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MP3 Voting</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
  <style>
    canvas {
      height: 20vh; /* 20% of the viewport height */
      width: 100%; /* 100% of the width */
    }
  </style>
</head>
<body>
  <h1>Vote for Your Favorite Tracks</h1>
  <div id="track-list"></div>
  <br>
  <div id="charts-container"></div>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getFirestore, doc, setDoc, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

    const firebaseConfig = {
      apiKey: "AIzaSyDp_cESC1PrXHxnTC2JMRdR928KXXwEvOw",
      authDomain: "gjaudio-d18d9.firebaseapp.com",
      projectId: "gjaudio-d18d9",
      storageBucket: "gjaudio-d18d9.firebasestorage.app",
      messagingSenderId: "740115381859",
      appId: "1:740115381859:web:a19505a463269198274256"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    await signInAnonymously(auth);

    const tracks = [
      { id: 'track1', title: 'Track 1', mp3: 'https://djangojazzcalgary.wordpress.com/wp-content/uploads/2025/05/track1.mp3', level: 'easy' },
      { id: 'track2', title: 'Track 2', mp3: 'https://djangojazzcalgary.wordpress.com/wp-content/uploads/2025/05/track2.mp3', level: 'medium' },
      { id: 'track3', title: 'Track 3', mp3: 'https://djangojazzcalgary.wordpress.com/wp-content/uploads/2025/05/track3.mp3', level: 'hard' },
    ];

    const container = document.getElementById('track-list');
    const chartsContainer = document.getElementById('charts-container');
    let charts = {};

    // Function to update the results for a single track
    async function updateResults(trackId) {
      const q = query(collection(db, "votes"), where("trackId", "==", trackId));
      const querySnapshot = await getDocs(q);
      let total = 0, count = 0;
      querySnapshot.forEach(doc => {
        total += doc.data().score;
        count++;
      });
      const avg = count > 0 ? (total / count).toFixed(2) : null;
      document.getElementById(`result-${trackId}`).textContent =
        avg ? `Average score: ${avg} (${count} vote${count > 1 ? 's' : ''})` : "No votes yet";

      // Update chart after results are updated
      updateChart();
    }

    // Function to update the chart for all tracks, grouped by level
    async function updateChart() {
      const levels = {};

      // Group tracks by their level
      for (const track of tracks) {
        const q = query(collection(db, "votes"), where("trackId", "==", track.id));
        const querySnapshot = await getDocs(q);
        let total = 0, count = 0;
        querySnapshot.forEach(doc => {
          total += doc.data().score;
          count++;
        });
        const avg = count > 0 ? (total / count).toFixed(2) : 0;
        if (!levels[track.level]) {
          levels[track.level] = { labels: [], averages: [], voteCounts: [] };
        }
        levels[track.level].labels.push(track.title);
        levels[track.level].averages.push(avg);
        levels[track.level].voteCounts.push(count);
      }

      // Now create the charts only for each level (easy, medium, hard)
      for (const level in levels) {
        if (!charts[level]) {
          const data = {
            labels: levels[level].labels,
            datasets: [{
              label: 'Average',
              data: levels[level].averages,
              borderWidth: 1,
              backgroundColor: 'rgba(54, 162, 235, 0.6)'
            }]
          };

          const config = {
            type: 'bar',
            data,
            options: {
              plugins: {
                datalabels: {
                  anchor: 'end',
                  align: 'top',
                  formatter: (value, context) => {
                    const index = context.dataIndex;
                    const votes = levels[level].voteCounts[index];
                    return `${value} (${votes})`;
                  },
                  font: {
                    weight: 'bold'
                  }
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  max: 10
                }
              }
            },
            plugins: [ChartDataLabels]
          };

          const chartContainer = document.createElement('div');
          chartContainer.innerHTML = `<h2>${level.charAt(0).toUpperCase() + level.slice(1)} Level</h2>`;
          const canvas = document.createElement('canvas');
          chartContainer.appendChild(canvas);
          chartsContainer.appendChild(chartContainer);

          const ctx = canvas.getContext('2d');
          charts[level] = new Chart(ctx, config);
        } else {
          // Update existing chart if it already exists
          charts[level].data.labels = levels[level].labels;
          charts[level].data.datasets[0].data = levels[level].averages;
          charts[level].update();
        }
      }
    }

    // Create the track list and initialize voting buttons
    for (const track of tracks) {
      const div = document.createElement('div');
      div.innerHTML = `
        <h3>* ${track.title}</h3>
        <audio controls src="${track.mp3}"></audio>
        <div>
          ${[...Array(10)].map((_, i) =>
            `<button data-score="${i+1}" data-id="${track.id}">${i+1}</button>`
          ).join(' ')}
        </div>
        <p id="result-${track.id}">Loading results...</p>
      `;
      container.appendChild(div);

      // Initially update the results for each track
      updateResults(track.id);

      // Add event listeners for voting
      div.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('click', async () => {
          const score = btn.dataset.score;
          const id = btn.dataset.id;
          const user = auth.currentUser;

          if (!user) {
            alert("User not signed in");
            return;
          }

          const voteRef = doc(db, "votes", `${user.uid}_${id}`);
          try {
            await setDoc(voteRef, {
              score: Number(score),
              trackId: id,
              user: user.uid
            });
            alert(`Voted ${score} on ${track.title}`);
            updateResults(id);
          } catch (err) {
            console.error("Error saving vote:", err);
            alert("Failed to vote.");
          }
        });
      });
    }

  </script>
</body>
</html>
